model {{model_name}}
  "Block that exchanges a vector of real values with Simulator"
  extends Modelica.Blocks.Interfaces.BlockIcon;
  extends Modelica.Blocks.Interfaces.DiscreteBlock(
    startTime=_startSamplingTime, 
    firstTrigger(fixed=true, start=false), 
    samplePeriod = _samplingPeriod);

///////////// THE CODE BELOW HAS BEEN AUTOGENERATED //////////////   
  {%- for dict_item in scalar_variables %}
  {%- if (dict_item["causality"])== "parameter" %}
  parameter {{dict_item["vartype"]}} {{dict_item["name"]}}(unit="{{dict_item["unit"]}}") = {{dict_item["start"]}}
    "{{dict_item["description"]}}";
  {%- elif (dict_item["causality"])== "input" %}
  Modelica.Blocks.Interfaces.RealInput {{dict_item["name"]}}(start={{dict_item["start"]}}, unit="{{dict_item["unit"]}}")
    "{{dict_item["description"]}}"{{dict_item["annotation"]}};
  {%- elif (dict_item["causality"])== "output" %}
  Modelica.Blocks.Interfaces.RealOutput {{dict_item["name"]}} (unit="{{dict_item["unit"]}}")
    "{{dict_item["description"]}}"{{dict_item["annotation"]}};
  {%- endif -%}
  {% endfor %}
  // Configuration specific parameters coming from 
  // the inputs of the Python export tool (SimulatorToFMU.py) 
  // used to generate the FMU
  {%- if con_path=="" %}
   parameter String _configurationFileName = "dummy.csv"
    "Path to the configuration or input file";
  {%- else  %}
  parameter String _configurationFileName = Modelica.Utilities.Files.loadResource("{{con_path}}")
    "Path to the configuration or input file";
  {%- endif %}
  parameter Boolean _saveToFile (fixed=true) = false "Flag for writing results"; 
  parameter Real _startSamplingTime (fixed=true) = 0.0 "The start sampling time";
  parameter Real _samplingPeriod (fixed=true) = 0.1 "The sampling frequency";
  
protected   

  {%- if has_memory=="false" %}
  parameter Boolean passPythonObject = false
    "Set to true if the Python function returns and receives an object, see User's Guide";
  {%- else  %}
  parameter Boolean passPythonObject = true
    "Set to true if the Python function returns and receives an object, see User's Guide";
  {%- endif %}
  parameter Integer nDblPar={{parameter_variable_names|length}} 
    "Number of double parameter values to sent to Simulator";
  parameter Integer nDblInp(min=1)={{input_variable_names|length}} 
    "Number of double input values to sent to Simulator";
  parameter Integer nDblOut(min=1)={{output_variable_names|length}}  
    "Number of double output values to receive from Simulator";
  
  SimulatorToFMU.Python{{python_vers}}.Functions.BaseClasses.PythonObject pytObj=
  SimulatorToFMU.Python{{python_vers}}.Functions.BaseClasses.PythonObject();
  Real dblInpVal[nDblInp] "Value to be sent to Simulator";
  
  {% if (input_variable_names|length==0) -%} 
  Real uR[nDblInp]
    "Variables used to collect values to be sent to Simulator";
  {%- else %}
  {% set comma = joiner(",") -%}  
  Real uR[nDblInp]={
  {%- for row in modelica_input_variable_names -%}
  {{comma()}}
  {{row}}
  {%- endfor %} 
  }"Variables used to collect values to be sent to Simulator";
  {%- endif %}
  {% if (output_variable_names|length==0) -%} 
  Real yR[nDblOut]
    "Variables used to collect values received from Simulator";
  {%- else %} 
  {% set comma = joiner(",") -%} 
  Real yR[nDblOut]={
  {%- for row in modelica_output_variable_names -%}
  {{comma()}}
  {{row}}
  {%- endfor %} 
  }"Variables used to collect values received from Simulator";
  {%- endif %}
  {% if (input_variable_names|length==0) -%} 
  parameter String dblInpNam[nDblInp]
    "Input variable names to be sent to Simulator";
  {%- else %}
  {% set comma = joiner(",") -%}   
  parameter String dblInpNam[nDblInp]={
  {%- for row in input_variable_names -%}
  {{comma()}}
  "{{row}}"
  {%- endfor %} 
  }"Input variable name to be sent to Simulator";
  {%- endif %}
  {% if (output_variable_names|length==0) -%} 
  parameter String dblOutNam[nDblOut]
    "Output variable names to be received from Simulator";
  {%- else %}
  {% set comma = joiner(",") -%} 
  parameter String dblOutNam[nDblOut]={
  {%- for row in output_variable_names -%}
  {{comma()}}
  "{{row}}"
  {%- endfor %} 
  }"Output variable names to be received from Simulator";
  {%- endif %}
  {% if (parameter_variable_names|length==0) -%} 
  parameter String dblParNam[nDblPar]
    "Parameter variable names to be sent to Simulator";
  {%- else %}
  {% set comma = joiner(",") -%}
  parameter String dblParNam[nDblPar]={
  {%- for row in parameter_variable_names -%}
  {{comma()}}
  "{{row}}"
  {%- endfor %}
  }"Parameter variable names to be sent to Simulator";
  {%- endif %}
  {% if (parameter_variable_names|length==0) -%} 
  parameter Real dblParVal[nDblPar]=zeros(nDblPar)
    "Parameter variable values to be sent to Simulator";
  {%- else %}
  {% set comma = joiner(",") -%} 
  parameter Real dblParVal[nDblPar]={
  {%- for row in parameter_variable_values -%}
  {{comma()}}
  {{row}}
  {%- endfor %}
  }"Parameter variable values to be sent to Simulator";
  {%- endif %}
  
///////////// THE CODE ABOVE HAS BEEN AUTOGENERATED //////////////  
  
  parameter String moduleName="{{module_name}}"
    "Name of the Python module that contains the function";
  parameter String functionName="exchange" 
    "Name of the Python function";

initial equation 
   dblInpVal  =  pre(uR);
   // The assignment of yR avoids the warning
   // "initial conditions for variables of type Real are not fully specified".
   // At startTime, the sampleTrigger is true and hence this value will
   // be overwritten.
   yR = zeros(nDblOut);
  
equation 
  when {sampleTrigger} then
	  // Compute values that will be sent to Simulator
	  for _cnt in 1:nDblInp loop
		dblInpVal[_cnt] = uR[_cnt];
	  end for;
	  
	  // Exchange data
	  yR = SimulatorToFMU.Python{{python_vers}}.Functions.simulator(
		  moduleName=moduleName,
		  functionName=functionName,
		  conFilNam=_configurationFileName,
		  modTim=time,
		  nDblInp=nDblInp,
		  dblInpNam=dblInpNam,
		  dblInpVal=dblInpVal,
		  nDblOut=nDblOut,
		  dblOutNam=dblOutNam,
		  nDblPar=nDblPar,
		  dblParNam=dblParNam,
		  dblParVal=dblParVal,
		  resWri=_saveToFile,
		  pytObj=pytObj,
		  passPythonObject=passPythonObject); 
  end when;
end {{model_name}};
